/* $Id: perf_init.C,v 1.1 1997/06/25 14:41:40 carr Exp $ */
/******************************************************************************/
/*        Copyright (c) 1990, 1991, 1992, 1993, 1994 Rice University          */
/*                           All Rights Reserved                              */
/******************************************************************************/
/************************************************************************
  perf_init.c -- Initializes the internal tables for the performance
  estimator module. Reads the machine data file generated by train.c.

  >> This software is in public domain. You may copy, modify and use this
  >> as you wish, provided you cite the author for the original source.
  >> Remember that anything free comes without any guarantee. 
  >> Use it at your own risk. 

  Author: Vas, July 1990.

  Modification History:

  Aug 4, 1990: modified perf_init() so that it first checks to see if
  a .fastinit file is present. This file is created by perf_init()
  after it reads the machine.data file for the first time. fast_init()
  considerably lowers the time required to initialize the performance
  estimator.  -Vas.

 ************************************************************************/

#include <libs/graphicInterface/cmdProcs/paraScopeEditor/include/ped.h>
#include <libs/graphicInterface/cmdProcs/paraScopeEditor/include/fort.h>
#include <libs/graphicInterface/cmdProcs/paraScopeEditor/include/symtab.h>
#include <libs/frontEnd/include/walk.h>
#include <libs/graphicInterface/cmdProcs/paraScopeEditor/include/dp.h>
#include <libs/graphicInterface/cmdProcs/paraScopeEditor/include/perf.h>
#include <libs/graphicInterface/cmdProcs/paraScopeEditor/include/PedExtern.h>

EXTERN(char, *getenv,(char*));

#define  MACHINE_DATA_FILE  "/perf/ncube/machine.data"

#define  LEN   5000

/* forward declarations */
char *get_ctype();
STATIC(int, check_if_kxgdin,(AST_INDEX stmt, int nlevel, Generic parm));
void fast_init();
void output_fastinit();

/*-----------------------------------------------------------------------
  perf_init -- reads the machine data file and constructs internal
  perfromance data tables. Returns these tables as a linked list.
  Once the data has been read and functions fitted to it, a new line
  is written at the beginning of the data file so that all this work
  need not be redone next time perf_init is called.
 -----------------------------------------------------------------------*/
TrainData *
perf_init()
{
  FILE         *fp;
  int          first_time = 1;
  static char  buf[LEN], *databuf, tempstr[100];
  TrainData    *tentry, *old;
  int          i, k, rc, len, id, ncount;
  float        *ta, loop_overhead;
  CommInfo     *tc;
  char  fname[120];
  char  name[120];

  Train_Data_List = NULL;
  fp = NULL;

  /* check if a fastinit file exists */
  /* looks for ~rn/perf/... */

  sprintf(name, "%s%s", getenv("RN_HOME"), MACHINE_DATA_FILE);
  strcpy(fname, name);
  strcat(fname, ".fastinit");

  /****  Fast init file should be opened here ****/
  /****  Bug in arith-cntl data line needs fixing ****/
  /** fp = fopen(fname, "r");  **/

  if (fp == NULL) { 
    /* open the data file */
    fp = fopen(name, "r");
    if (fp == NULL) {
      message("Could not open machine data file %s.\n", name);
      return Train_Data_List;
    }
  }
  else {
    /* found a .fastinit file, so do fast initialization */
    fast_init(fp);
    fclose(fp);
    return Train_Data_List;
  }

  /*
   * NOTE:  perf_init expects the data file <fname> to be in the
   * following format (see ~vas/Express/measure/ncube.data):
   *
   *    @ nprocs dstride numcomm npoints
   *    ARITH_CNTL: z1, z2, z3, ..., z12
   *    iSR: x1,y1 x2,y2 x3,y3, ...
   *    vSR: x1,y1 x2,y2 x3,y3, ...
   *    EXCH: x1,y1 x2,y2 x3,y3, ...
   *    COMBN: x1,y1 x2,y2 x3,y3, ...
   *    BCAST: x1,y1 x2,y2 x3,y3, ...
   *    @ nprocs dstride numcomm npoints
   *    ....
   *    ....
   *
   * nprocs is the number of processors, dstride is the data stride and
   * must be either UNIT or NON_UNIT, numcomm is the number of
   * communication utilities tested (in the above example segment,
   * numcomm = 5 = { iSR, vSR, EXCH, COMBN, BCAST }, npoints is the
   * number of data points (x,y pairs) per communication utility. x is
   * assumed to be in bytes and y in millisecs. ARITH_CNTL is the timing
   * for several arithmetic and control flow operations, and these data
   * points are assumed to be in decimal exponential notation.
   *
   */

  for ( ;  ; ) {

    if (feof(fp)) {
      /* reached eof */
      fclose(fp);
      return Train_Data_List;
    }

    /* read next line */
    fgets(buf, LEN, fp);

    sscanf(buf, "%s %*s", tempstr);
    if (strcmp(tempstr, "@") == 0) {  /* process header */
      ncount = 0;
      loop_overhead = 0.0;
      tentry = (TrainData *) get_mem(sizeof(TrainData), "perf_init");
      rc = sscanf(buf, "@ %d %d %d %d", &tentry->nprocs, &tentry->dstride,
		  &tentry->numcomm, &tentry->npoints);
      if (rc <= 0) {
	/* eof ? */
	fclose(fp);
	return Train_Data_List;
      }
      debug(" NumProcs: %d  DataStride: %d \n---------------------------------\n\n",
	    tentry->nprocs, tentry->dstride);

      /* allocate an array of size numcomm to store the communication data */
      tentry->comminfo = (CommInfo *) get_mem(sizeof(CommInfo)*(tentry->numcomm+1),
					      "perf_init");
      if (first_time == 1) {
	first_time = 0;
	Train_Data_List = tentry;  /* set global variable train_data_list */
	old = tentry;
	tentry->next = NULL;
      }
      else {
	/* add to list */
	old->next = tentry;
	old = tentry;
	tentry->next = NULL;
      }
      continue;
    }

    /* else process performance data */

    rc = sscanf(buf, "%d: %*s", &id);
    if (rc <= 0) {
      /* eof ? */
      fclose(fp);
      return Train_Data_List;
    }

/*** Uli    databuf = buf + 3 --- bug fix  ***/
    databuf = buf + 4;
/***
   Note: tempstr is a string, i.e. has the char \n at its end.
	 e.g. tempstr = "3" with strlen(tempstr) == 2.
 ***/
    len = strlen(databuf);
    i = 0; k = 0;

    if (id == ARITH_CNTL) {  /* process arithmetic and control data */
      debug("Arithmetic/control data: ");
      while (i <= len) {
	rc = sscanf(databuf+i, "%s", tempstr);
	if (rc <= 0) {
	  printf("error scanning arith-cntl data\n");
	  return Train_Data_List;
	}
	ta = tentry->arithdata;
	rc = sscanf(tempstr, "%e", &(ta[k]));
	/* convert data to secs */
	ta[k] = ta[k] / 1000.0;
	if (k == T_DOLOOP)
	  loop_overhead = ta[k];
	else
	  ta[k] = ta[k] - loop_overhead;
	debug("  %e", ta[k]);
	k++;
	if (k >= NUM_ARITH_CNTL) break;
	i += strlen(tempstr) + 2;
      }
    }
    else {  /* process communication data */
      if (ncount >= tentry->numcomm)  break;
      debug("\n\n");
      debug("Communication type: %s\n\n", get_ctype(id));
      tc = tentry->comminfo;
      chi_squared_fit(databuf, tentry->npoints, &(tc[id]));
      ncount++;
    }
    
  }

  /* write out a .fastinit file for use the next time perf_init is called */
  /*** bug needs to be fixed in this routine! ***/
  /** output_fastinit(fname); **/

  return Train_Data_List;
  
}


char * get_ctype(int ctype)
{
  switch(ctype) {
  case iSR:    return ("iSR");
  case vSR:    return ("vSR");
  case EXCH1:  return ("EXCH");
  case BCAST:  return ("BCAST");
  case COMBN:  return ("COMBN");
  default:     return (" ");
  }
}


/*------------------------------------------------------------------------
   Numprocs_initialize -- look for the "kxgdin" function invocation in
   the program, and parse it to initialize the Num_procs global variable.
  ------------------------------------------------------------------------*/
void
Numprocs_initialize(AST_INDEX root)
{
  AST_INDEX  stmt, body;
  static AST_INDEX  sym[2];
  static int   val[2];
  AST_INDEX    parmlist, curr, ref, array, left, right;
  static char  name[20], ref_name[20], array_name[20];
  int          num, numparms, nprocs = 1;

  /* initialize the global variable Program_Root */
  Program_Root = AST_NIL;
  
  stmt = AST_NIL;

  /* walk the tree starting from root */
  walk_statements(root, 0, NULL, check_if_kxgdin, (Generic) &stmt);

  if (stmt == AST_NIL) {
      Num_Procs = 1; /* DEFAULT VALUE */
  }
  else {
    get_assignment_info(stmt, &left, &right);
    get_function_info(right, name, &parmlist, &numparms, &body);
    /* find out the value of Num_Procs */
    sym[1] = list_first(parmlist);
    val[1] = 1;
    resolve_symbols(stmt, 1, sym, val);
    ref = list_next(sym[1]);
    sprintf(ref_name, "%s", gen_get_text(ref));
    
    /* search backwards looking for val[1] references to ref */
    curr = list_prev(stmt);
    num = val[1];
    while (curr != AST_NIL && num > 0) {
      if (is_assignment(curr)) {
	get_assignment_info(curr, &left, &right);
	if (is_subscript(left)) 
	  array = gen_SUBSCRIPT_get_name(left);
	else
	  array = left;
	sprintf(array_name, "%s", gen_get_text(array));
	if (strcmp(ref_name, array_name) == 0) {
	  num--;
	  sym[1] = right;
	  val[1] = 1;
	  resolve_symbols(curr, 1, sym, val);
	  nprocs *= val[1];
	}
      }
      curr = list_prev(curr);
    }
    if (nprocs > 1) 
      Num_Procs = nprocs;
    else
      Num_Procs = 1; /* DEFAULT VALUE */
  }
  
}

/*------------------------------------------------------------------------
   check_if_kxgdin -- check if this stmt is a KXGDIN call. If yes, then
   set parm to its AST_INDEX and abort walk.
  ------------------------------------------------------------------------*/
static int
check_if_kxgdin(AST_INDEX stmt, int nlevel, Generic parm)
{
  AST_INDEX  *indx, parmlist, left, right, body;
  static char name[20];
  int        numparms;

  indx = (AST_INDEX *) parm;

  /* check if this is a parameter statement */
  if (is_parameter(stmt)) {
    process_parameter_stmt(stmt);
  }
  
  if (! is_assignment(stmt))
    return(WALK_CONTINUE);

  get_assignment_info(stmt, &left, &right);

  if (is_invocation(right) || is_subscript(right)) {
    /* Note: due to an Rn bug, Ped sometimes gets confused between
       function invocations and subscript references */
    get_function_info(right, name, &parmlist, &numparms, &body);
    if (strcmp("kxgdin", name) == 0) {
      *indx = stmt;
      return (WALK_ABORT);
    }
  }

  return (WALK_CONTINUE);
}


/*----------------------------------------------------------------------------
   fast_init -- fast initialization of performance data into internal storage.
  ----------------------------------------------------------------------------*/
void fast_init(FILE *fp)
{
  TrainData  *td, *old;
  CommData   *cd, *oldcd;
  CommInfo   *ci;
  float      *ta;
  int        i, first_time=1, first=1, rc, id, ncount, k, len;
  static char  buf[LEN], *databuf, tempstr[100];
  
  for ( ;  ; ) {

    if (feof(fp)) 
      return;  /* reached eof */

    /* read next line */
    fgets(buf, LEN, fp);

    sscanf(buf, "%s %*s", tempstr);
    if (strcmp(tempstr, "@") == 0) {  /* process header */
      ncount = 0;
      td = (TrainData *) get_mem(sizeof(TrainData), "fast_init");
      sscanf(buf, "@ %d %d %d %d", &(td->nprocs), &(td->dstride),
		  &(td->numcomm), &(td->npoints));

      /* allocate an array of size numcomm+1 to store the communication data */
      td->comminfo = (CommInfo *) get_mem(sizeof(CommInfo) * (td->numcomm + 1),
					  "fast_init");
      if (first_time == 1) {
	first_time = 0;
	Train_Data_List = td;  /* set global variable train_data_list */
	td->next = NULL;
      }
      else {
	/* add to list */
	old->next = td;
	td->next = NULL;
      }
      old = td;
      continue;
    }

    /* else process performance data */

    rc = sscanf(buf, "%d : %*s", &id);
    if (rc <= 0)
      return;  /* eof ? */
    databuf = buf + 3;
    len = strlen(databuf);
    i = 0; k = 0;
    ta = td->arithdata;

    if (id == ARITH_CNTL) {  /* process arithmetic and control data */
      while (i <= len) {
	sscanf(databuf+i, "%s %*s", tempstr);
	sscanf(tempstr, "%e", &(ta[k]));
	k++;
	if (k >= NUM_ARITH_CNTL) break;
	i += strlen(tempstr) + 1;
      }
    }
    else {  /* process communication data */
      if (ncount >= td->numcomm)  break;
      ci = td->comminfo;
      sscanf(databuf, "%s %*s", tempstr);
      sscanf(tempstr, "%e", &(ci[id].StartCost));
      databuf += strlen(tempstr) + 1;
      sscanf(databuf, "%s # %*s", tempstr);
      sscanf(tempstr, "%e", &(ci[id].pktization));
      databuf += strlen(tempstr) + 3;
      len = strlen(databuf);
      first = 1;
      while (i <= len) {
	sscanf(databuf+i, "%s %*s", tempstr);
	cd = (CommData *) get_mem(sizeof(CommData), "fast_init");
	sscanf(tempstr, "%d,%d,%e,%e",
	       &(cd->xrange[0]), &(cd->xrange[1]), &(cd->a), &(cd->b));
	cd->next = NULL;
	i += strlen(tempstr) + 1;
	if (first == 1) {
	  first = 0;
	  ci[id].commdata = cd;
	}
	else {
	  oldcd->next = cd;
	}
	oldcd = cd;
      }
      ncount++;
    }
    
  }

}

/*--------------------------------------------------------------------------
   output_fastinit -- write out internal perf data to a .fastinit file.
  --------------------------------------------------------------------------*/
void output_fastinit(char *fname)
{
  FILE  *fp;
  TrainData  *td;
  CommData   *cd;
  CommInfo   *ci;
  int        i;
  float      *ta;
  int        *cx;

  /* open the file for writing */
  fp = fopen(fname, "w");

  if (fp == NULL) {
    printf("Unsuccessful!\n");
    return;  /* could not create .fastinit file */
  }

  for (td = Train_Data_List; td != NULL; td = td->next)
    {
      /* write a header for this train data entry */
      fprintf(fp, "@ %d %d %d %d\n",
	      td->nprocs, td->dstride, td->numcomm, td->npoints);

      /* write the arithdata */
      ta = td->arithdata;
      fprintf(fp, "0: ");
      for (i = 0; i < NUM_ARITH_CNTL; i++) {
	fprintf(fp, " %e", ta[i]);
      }
      fprintf(fp, "\n");

      /* write the commdata */
      for (i = 1; i <= td->numcomm; i++)
	{
	  /* write the comminfo */
	  ci = td->comminfo;
	  fprintf(fp, "%d: %e %e # ", i, ci[i].StartCost, ci[i].pktization);

	  /* write the commdata for each packet */
	  for (cd = ci[i].commdata; cd != NULL; cd = cd->next)
	    {
	      cx = cd->xrange;
	      fprintf(fp, " %d,%d,%e,%e",
		      cx[0], cx[1], cd->a, cd->b);
	    }
	  fprintf(fp, "\n");
	}
    }

  /* close the .fastinit file */
  fclose(fp);

}

